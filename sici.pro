
;+
;:Description:
;   Compute sine and cosine integral according to Cephes Mathematical Functions Library sicif.c
;https://github.com/jeremybarnes/cephes/blob/master/single/sicif.c
;only for real number computation, not for complex number

;:Input: 
;   x, variable, could be array
;
;:Accuracy: single percision. cf. Python scipy.special.sici()
;              IDL                                      Python
;sici(0)   0.0000000           Inf                  |  (0.0, -inf)
;sici(-1) -0.94608307172750605 0.33740392297856242  | (-0.9460830703671831, 0.33740392290096816)
;sici(2)   1.6054129857232535  0.42298083000007314  | (1.605412976802695, 0.422980828774865)
;sici(-4) -1.7582031625305645 -0.14098168162434588  | (-1.758203138949053, -0.1409816978869305)
;sici(-9) -1.6650400746748639  0.055347530559748462 | (-1.6650400758296022, 0.05534753133313361)
;sici(1e5) 1.5708063203993941  3.5758791572935119e-07 | (1.570806320399394, 3.575879157293513e-07)
;sici(2e9) 1.5707963265928417  4.5735523701573300e-10 | (1.5707963265928415, 4.573552292234932e-10)
;
;:Author: Sihui Zhong (s.zhong3@exeter.ac.uk, sihui.zhong@outlook.com)
;-

function sici, xx
 
  SN = 1d*[-8.39167827910303881427E-11,4.62591714427012837309E-8,$
    -9.75759303843632795789E-6,9.76945438170435310816E-4,$
    -4.13470316229406538752E-2,1.00000000000000000302E0]

  SD = 1d*[2.03269266195951942049E-12,1.27997891179943299903E-9,$
    4.41827842801218905784E-7,9.96412122043875552487E-5,$
    1.42085239326149893930E-2,9.99999999999999996984E-1]

  CN = 1d*[2.02524002389102268789E-11,-1.35249504915790756375E-8,$
    3.59325051419993077021E-6,-4.74007206873407909465E-4,$
    2.89159652607555242092E-2,-1.00000000000000000080E0]

  CD = 1d*[4.07746040061880559506E-12,3.06780997581887812692E-9,$
    1.23210355685883423679E-6,3.17442024775032769882E-4,$
    5.10028056236446052392E-2,4.00000000000000000080E0];

  FN4 = 1d*[4.23612862892216586994D0,5.45937717161812843388D0,$
    1.62083287701538329132D0,1.67006611831323023771D-1,$
    6.81020132472518137426D-3,1.08936580650328664411D-4,$
    5.48900223421373614008D-7];

  FD4 = $;/*  1.00000000000000000000E0,*/
    1d*[8.16496634205391016773D0,7.30828822505564552187D0,$
    1.86792257950184183883D0,1.78792052963149907262D-1,$
    7.01710668322789753610D-3,1.10034357153915731354D-4,$
    5.48900252756255700982D-7];

  FN8 = 1d*[4.55880873470465315206E-1,7.13715274100146711374E-1,$
    1.60300158222319456320E-1,1.16064229408124407915E-2,$
    3.49556442447859055605E-4,4.86215430826454749482E-6,$
    3.20092790091004902806E-8,9.41779576128512936592E-11,$
    9.70507110881952024631E-14]

  ;/*  1.00000000000000000000E0,*/
  FD8 = 1d*[9.17463611873684053703E-1,1.78685545332074536321E-1,$
    1.22253594771971293032E-2,3.58696481881851580297E-4,$
    4.92435064317881464393E-6,3.21956939101046018377E-8,$
    9.43720590350276732376E-11,9.70507110881952025725E-14];

  GN4 = 1d*[8.71001698973114191777E-2,6.11379109952219284151E-1,$
    3.97180296392337498885E-1,7.48527737628469092119E-2,$
    5.38868681462177273157E-3,1.61999794598934024525E-4,$
    1.97963874140963632189E-6,7.82579040744090311069E-9];

  GD4 = 1d*[1.64402202413355338886E0,6.66296701268987968381E-1,$
    9.88771761277688796203E-2,6.22396345441768420760E-3,$
    1.73221081474177119497E-4,2.02659182086343991969E-6,$
    7.82579218933534490868E-9];

  GN8 = 1d*[6.97359953443276214934E-1,3.30410979305632063225E-1,$
    3.84878767649974295920E-2,1.71718239052347903558E-3,$
    3.48941165502279436777E-5,3.47131167084116673800E-7,$
    1.70404452782044526189E-9,3.85945925430276600453E-12,$
    3.14040098946363334640E-15];

  GD8 = 1d*[1.68548898811011640017E0,4.87852258695304967486E-1, $
    4.67913194259625806320E-2,1.90284426674399523638E-3, $
    3.68475504442561108162E-5,3.57043223443740838771E-7, $
    1.72693748966316146736E-9,3.87830166023954706752E-12,$
    3.14040098946363335242E-15];

  ;constants
  EUL = 0.57721566490153286061d ; Euler's constant
  PIO2F = !dpi/2.0
  xx = xx*1d

  n= n_elements(xx)
  arr = dblarr(2,n)
  
  for i=0,n-1 do begin
    x = xx[i]
    
    if x lt 0.0 then begin
      sign = -1
      x = -x
    endif else begin
      sign = 0
    endelse

    if x eq 0 then begin
      si = 0.0
      ci = -!values.F_INFINITY ;-std::numeric_limits<double>::infinity()
      arr[*,i] = [si,ci]
    endif

    if x gt 1.0e9 then begin
      if x eq !values.F_INFINITY then begin
        if sign eq -1 then begin
          si = -!dpi/2.0
          ci = !values.F_NAN
        endif else begin
          si = !dpi/2.0
          ci = 0
        endelse
        arr[*,i] = [si,ci]
      endif
      si = PIO2F - cos(x)/x
      ci = sin(x)/x
      arr[*,i] = [si,ci]
    endif else begin
      if x gt 4.0 then begin ;
        s = sin(x)
        c = cos(x)
        z = 1.d/(x*x)
        if x lt 8.0 then begin
          ;asympt
          f = poly(z,reverse(FN4)) / (x*poly(z,[reverse(FD4),1.E0])) ;f = polevl( z, FN4, 6 ) / (x * p1evl( z, FD4, 7 ))
          g = z*poly(z,reverse(GN4)) / poly(z,[reverse(GD4),1.E0]);g = z * polevl( z, GN4, 7 ) / p1evl( z, GD4, 7 )
        endif else begin
          f = poly(z,reverse(FN8)) / (x*poly(z,[reverse(FD8),1.d]))
          g = z*poly(z,reverse(GN8)) / poly(z,[reverse(GD8),1.d])
          ;f = polevlf( z, FN8, 8 ) / (x * p1evlf( z, FD8, 8 ))
          ;g = z * polevlf( z, GN8, 8 ) / p1evlf( z, GD8, 9 )
        endelse
        si = PIO2F - f*c - g*s
        if sign then si = -si
        ci = f*s - g*c
        arr[*,i] = [si,ci]
      endif else begin ;
        ;ploy(X,C) ;return C[0] + c[1] * X + c[2]*x^2 + ...
        z = x * x
        s = x * poly(z,reverse(SN)) / poly(z,reverse(SD)) ;s = x * polevl(z, SN, 5) / polevl(z, SD, 5)
        c = z * poly(z,reverse(CN)) / poly(z,reverse(CD)) ;c = z * polevl(z, CN, 5) / polevl(z, CD, 5)
        ;rational function

        if sign then s=-s

        si = s
        ci = EUL + alog(x) + c ; real part if x<0

        arr[*,i] = [si, ci]
      endelse

    endelse
    

  endfor
  return,arr

end